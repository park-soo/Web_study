/*
        COLLECTION 컬렌션
        데이터 타입(배열)
        같은 데이터 타입을 가진 요소로 구성
        여러 ROW를 가질 수 있음.(TABLE)
        1. 가변 길이 배열(Variable size array(VARRAY))
                TYPE [타입명] IS {VARRAY | VARYING ARRAY} (크기) OF 요소데이터 타입 [NOT NULL];
                선언시에 배열의 전체 크기를 명시.
                순서대로 참조함.
        2. 중첩 테이블(Nested table)
                TYPE [타입명] IS TABLE OF 요소데이터 타입 [NOT NULL];
                크기 선언 불필요. 크기 제한이 없음.
                순서대로 참조할 필요없음.
        3. 연관 배열(Associative Array(INDEX-BY TABLE))
                TYPE [타입명] IS TABLE OF 요소데이터 타입 [NOT NULL]
                        INDEX BY [PLS_INTEGER | BINARY_INTEGER | VARCHAR2(크기)];
                키와 값을 쌍으로 타입 (HASH MAP과 동일한 개념)
                키 -> INDEX.
        컬렉션 메서드
        DELETE, TRIM, EXTEND, EXISTS, FIRST, LAST, COUNT, LIMIT, PRIOR, NEXT
*/

create or replace PROCEDURE PROC_COLLECTION
IS
        -- 타입 선언
        TYPE VARR IS VARRAY(3) OF INTEGER;  -- INTEGER타입의 요소 3개
        TYPE NEST IS TABLE OF VARCHAR2(10);     --VARCHAR2(10) 타입 요소, 크기 설정 없음
        TYPE IT_NUMBER IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
        -- 키 PLS_INTEGER, 값은 NUMBER 타입의 요소
        TYPE IT_STR1  IS TABLE OF VARCHAR2(32) INDEX BY PLS_INTEGER;
        --  키 PLS_INTEGER, 값은 VARCHAR2 타입의 요소
        TYPE IT_STR2  IS TABLE OF VARCHAR2(32) INDEX BY VARCHAR2(20);
        -- 키 VARCHAR2, 값은 VARCHAR2 타입의 요소
        
        -- 변수 선언
        VARR1 VARR;
        NEST1 NEST;
        ASS1 IT_NUMBER;
        ASS2 IT_STR1;
        ASS3 IT_STR2;
BEGIN
        -- 변수에 값 할당
        VARR1 := VARR(1,10,100);
        NEST1 := NEST('A','B','C','D','E');
        ASS1(99) := 20230329;
        ASS2(1) := '연관배열 문자열';
        ASS3('HOPE') := '희망';
        ASS3('LOVE') := '사랑';
        
        -- 값을 읽기
        DBMS_OUTPUT.PUT_LINE(VARR1(1));
        DBMS_OUTPUT.PUT_LINE(NEST1(2));
        DBMS_OUTPUT.PUT_LINE(ASS1(99));
        DBMS_OUTPUT.PUT_LINE(ASS2(1));
        DBMS_OUTPUT.PUT_LINE(ASS3('LOVE'));
        DBMS_OUTPUT.PUT_LINE(ASS3('HOPE'));
        
END PROC_COLLECTION;


create or replace PROCEDURE PROC_COLL_METHOD
IS
        TYPE VA1 IS VARRAY(6) OF VARCHAR2(10);  -- 가변 길이 배열
        TYPE NT1 IS TABLE OF VARCHAR2(20);  -- 중첩 테이블
        TYPE IT1 IS TABLE OF VARCHAR2(40) INDEX BY VARCHAR2(10); -- 연관배열
        
        VA_TEST VA1;
        NT_TEST NT1;
        IT_TEST IT1;
        
        V_CNT NUMBER := 0;
BEGIN
        IT_TEST('A') := 'VALUE FOR A';
        IT_TEST('B') := 'VALUE FOR B';
        IT_TEST('C') := 'VALUE FOR C';
        V_CNT := IT_TEST.COUNT;
        DBMS_OUTPUT.PUT_LINE('IT_TEST COUNT BEFORE DEL :' || V_CNT);
        IT_TEST.DELETE('A','B');
        V_CNT := IT_TEST.COUNT;
        DBMS_OUTPUT.PUT_LINE('IT_TEST COUNT AFTER DEL :' || V_CNT);
        
        NT_TEST := NT1('FIRST','SECOND','THIRD','FOURTH','FIFTH');
        NT_TEST.TRIM(2);
        DBMS_OUTPUT.PUT_LINE(NT_TEST(1));
        DBMS_OUTPUT.PUT_LINE(NT_TEST(2));
        DBMS_OUTPUT.PUT_LINE(NT_TEST(3));
--        DBMS_OUTPUT.PUT_LINE(NT_TEST(4));
--        DBMS_OUTPUT.PUT_LINE(NT_TEST(5));
        NT_TEST.EXTEND;
        DBMS_OUTPUT.PUT_LINE(NT_TEST(4));
        NT_TEST(4) := 'FOURTH';
        DBMS_OUTPUT.PUT_LINE(NT_TEST(4));
        NT_TEST.EXTEND(2,2);
        DBMS_OUTPUT.PUT_LINE(NT_TEST(1));
        DBMS_OUTPUT.PUT_LINE(NT_TEST(5));
        DBMS_OUTPUT.PUT_LINE(NT_TEST(6));
        
        VA_TEST := VA1('1ST','2ND','3RD','4TH','5TH');
        FOR I IN VA_TEST.FIRST..VA_TEST.LAST
        LOOP
                DBMS_OUTPUT.PUT_LINE(I||'번째 요소 값:' ||VA_TEST(I));
        END LOOP;
                DBMS_OUTPUT.PUT_LINE('VA COUNT:' || VA_TEST.COUNT);
                DBMS_OUTPUT.PUT_LINE('NT COUNT:' || NT_TEST.COUNT);
                DBMS_OUTPUT.PUT_LINE('VA LIMIT:' || VA_TEST.LIMIT);
                DBMS_OUTPUT.PUT_LINE('NT LIMIT:' || NT_TEST.LIMIT);
        
                DBMS_OUTPUT.PUT_LINE('FIRST:' || VA_TEST.FIRST);
                DBMS_OUTPUT.PUT_LINE('LAST:' || VA_TEST.LAST);
                DBMS_OUTPUT.PUT_LINE('FIRST PRIOR:' || VA_TEST.PRIOR(VA_TEST.FIRST));
                DBMS_OUTPUT.PUT_LINE('LAST NEXT:' || VA_TEST.NEXT(VA_TEST.LAST));
                DBMS_OUTPUT.PUT_LINE('INDEX 3 PRIOR:' || VA_TEST.PRIOR(3));
                DBMS_OUTPUT.PUT_LINE('INDEX 3 NEXT:' || VA_TEST.NEXT(3));
                
                IF NT_TEST.EXISTS(1) THEN
                        DBMS_OUTPUT.PUT_LINE('있음');
                ELSE
                        DBMS_OUTPUT.PUT_LINE('없음');
                END IF;
END PROC_COLL_METHOD;
