-- INDEX
CREATE INDEX EMP_INDEX
ON EMP(EMPNO, ENAME);
DROP INDEX EMP_INDEX;

-- DICTIONARY
SELECT * FROM DICT;
SELECT * FROM DICTIONARY
WHERE TABLE_NAME LIKE 'USER%';
/*
    USER_??     사용자 관련 객체 정보
    ALL_??      사용자 사용가능한 객체 정보
    DBA_??      DB관련 정보(SYSTEM SYS)
    V$_??       VIEW 관련
*/

SELECT * FROM USER_TABLES;
SELECT * FROM ALL_TABLES WHERE OWNER='SCOTT';
--SCOOT 계정이라서 권한이 없어서 안됨 (DB관련은)
SELECT * FROM DBA_TABLES;
SELECT * FROM DBA_USERS;
-------------------------------------------------------
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_IND_COLUMNS;
SELECT * FROM OBJ;

-- VIEW
CREATE VIEW VW_EMP2
AS (SELECT E.*, D.DNAME,D.LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO);

SELECT * FROM USER_VIEWS;

/*
    SEQUENCE
    CREATE SEQUENCE [SEQ NAME]
    INCREMENT BY [NUM]
    START WITH [START NUM]
    NOMINVALUE OR MINVALUE [MINNUM]
    NOMAXVALUE OR MAXVALUE [MAXNUM]
    CYCLE OR NOCYCLE
    CACHE OR NOCACHE
*/

DROP SEQUENCE EX_SEQ;
CREATE SEQUENCE EX_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 1000
NOCYCLE
NOCACHE;

DROP TABLE SEQTABLE;
CREATE TABLE SEQTABLE(SEQNUM NUMBER(4), TESTTXT VARCHAR2(10));
SELECT * FROM SEQTABLE;
INSERT INTO SEQTABLE VALUES(EX_SEQ.NEXTVAL, 'TEST TEXT');
SELECT EX_SEQ.CURRVAL FROM DUAL;
SELECT EX_SEQ.NEXTVAL FROM DUAL;
ALTER SEQUENCE EX_SEQ INCREMENT BY -2;

/*
    줄번호
*/
SELECT ROWNUM,A.*
FROM(
        SELECT E.*
        FROM EMP E
        ORDER BY E.ENAME
) A
ORDER BY A.JOB;

SELECT ROW_NUMBER() OVER(ORDER BY E.JOB, E.ENAME) ROW_NUM
    ,E.*
FROM EMP E
ORDER BY E.JOB, E.ENAME;

-- OVER(PARTITION BY)
SELECT JOB, SUM(SAL)
FROM EMP
WHERE JOB IN('MANAGER','SALESMAN')
GROUP BY JOB
ORDER BY JOB;

SELECT EMPNO, ENAME, DEPTNO, JOB, SUM(SAL) OVER(PARTITION BY JOB,DEPTNO)
FROM EMP
WHERE JOB IN('MANAGER','SALESMAN')
ORDER BY JOB,DEPTNO;

SELECT EMPNO, ENAME, JOB, SAL, RANK() OVER(ORDER BY SAL DESC) AS 등수, DENSE_RANK() OVER(ORDER BY SAL DESC) AS 등수2
FROM EMP
WHERE SAL IS NOT NULL
ORDER BY SAL DESC;


/*
    SYNONYM 동의어
    CREATE PUBLIC SYNONYM [NAME]
    FOR [TARGET]
*/
CREATE SYNONYM DE
FOR DEPT;
SELECT * FROM DE;


-- Q1
DROP TABLE EMPIDX;
CREATE TABLE EMPIDX
AS SELECT * FROM EMP;
-- EMPIDX 테이블의 EMPNO값을 기준으로 한 인덱스 IDX_EMPIDX_EMPNO 생성

CREATE INDEX IDX_EMPIDX_EMPNO
ON EMPIDX(EMPNO);

SELECT * FROM USER_INDEXES WHERE INDEX_NAME='IDX_EMPIDX_EMPNO';

-- Q2 급여가 1500을 넘는 사람의 사번 이름 직급 급여
-- 를 담은 뷰 EMPIDX_OVER15를 생성

CREATE VIEW EMPIDX_OVER15
AS (SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL FROM EMP E WHERE E.SAL>1500);

SELECT * FROM USER_VIEWS WHERE VIEW_NAME='EMPIDX_OVER15';

-- Q3
DROP TABLE DEPTSEQ;
CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT;
-- SEQ_DEPTSEQ 시퀀스를 생성 (1에서 99까지 1씩 증가 순환없음 캐쉬 안씀)
CREATE SEQUENCE SEQ_DEPTSEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 99
NOCYCLE
NOCACHE;
-- SEQ_DEPTSEQ 시퀀스 삭제
DROP SEQUENCE SEQ_DEPTSEQ;
-- SEQ_DEPTSEQ 시퀀스를 생성 (10에서 100까지 60부터 10씩 증가 순환없음 캐쉬 안씀)
CREATE SEQUENCE SEQ_DEPTSEQ
INCREMENT BY 10
START WITH 60
MINVALUE 10
MAXVALUE 100
CYCLE
NOCACHE;

INSERT INTO DEPTSEQ(DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPTSEQ.NEXTVAL,'DATABASE','BUSAN');
SELECT SEQ_DEPTSEQ.CURRVAL FROM DUAL;
SELECT SEQ_DEPTSEQ.NEXTVAL FROM DUAL;

SELECT * FROM DEPTSEQ;

-- UNION
SELECT DEPTNO, ENAME NAME FROM EMP WHERE DEPTNO=10
UNION
-- 다른테이블이여도 컬러명만 같게 해주면 됨.
SELECT DEPTNO, DNAME NAME FROM DEPT;

SELECT * FROM EMP WHERE DEPTNO=20
-- UNION은 중복된 값을 처리 하는데 UNION ALL 중복처리를 안하고 다 보여준다.
UNION ALL
SELECT * FROM EMP WHERE DEPTNO=20;

/*
    계층구조
    START WITH [CONDITION]
    CONNECT BY PRIOR [CONDITION]
*/
SELECT LEVEL EMPNO, ENAME, MGR, JOB
FROM EMP
START WITH JOB='PRESIDENT'
CONNECT BY PRIOR EMPNO=MGR AND LEVEL <=2;

/*
    숫자 찍기
*/

SELECT * FROM(SELECT ROWNUM NUM FROM EMP E, EMP A) WHERE NUM<=24;

SELECT * FROM (
        SELECT 1 AS NUM FROM DUAL UNION ALL
        SELECT 2 FROM DUAL UNION ALL
        SELECT 3 FROM DUAL UNION ALL
        SELECT 4 FROM DUAL UNION ALL
        SELECT 5 FROM DUAL UNION ALL
        SELECT 6 FROM DUAL
        );
        
SELECT LEVEL FROM DUAL
CONNECT BY LEVEL <=24;




